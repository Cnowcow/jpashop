(findMember == member)가 true가 나오는 이유는 JPA의 1차 캐시와 엔티티 동일성 보장 때문입니다. 이를 이해하기 위해서는 JPA가 엔티티를 어떻게 관리하고, EntityManager가 어떤 역할을 하는지 알아야 합니다.

1. 1차 캐시와 엔티티 관리
1차 캐시는 EntityManager가 관리하는 메모리 내의 캐시입니다. 엔티티를 조회하거나, 저장할 때 EntityManager는 해당 엔티티를 1차 캐시에 저장하고 관리합니다.
EntityManager를 통해 동일한 @Transactional 범위 내에서 동일한 엔티티를 다시 조회하게 되면, 데이터베이스를 다시 조회하지 않고 1차 캐시에 저장된 엔티티를 반환합니다.
JPA에서는 같은 EntityManager 내에서 동일한 식별자를 가진 엔티티는 항상 동일한 인스턴스로 관리됩니다. 따라서, 두 번 조회하더라도 동일한 객체(참조)를 반환하게 됩니다.
2. 실제 코드 동작
memberRepository.save(member)를 호출하면, EntityManager는 member 객체를 데이터베이스에 persist하고, 동시에 1차 캐시에 해당 객체를 저장합니다.
이후 memberRepository.find(savedId)를 호출하면, EntityManager는 먼저 1차 캐시에서 해당 ID를 가진 엔티티가 있는지 확인합니다. 이때 1차 캐시에 이미 member가 저장되어 있으므로, 데이터베이스에서 다시 조회하지 않고, 1차 캐시에 있는 member 객체를 그대로 반환합니다.
따라서 findMember와 member는 동일한 인스턴스(객체 참조)를 가리키게 되며, (findMember == member)는 true가 됩니다.
3. 동일성 보장
JPA는 트랜잭션 내에서 같은 ID를 가진 엔티티는 동일한 객체로 보장해줍니다. 이를 통해 애플리케이션은 엔티티의 상태 변화를 일관되게 추적하고 관리할 수 있습니다.
즉, == 연산자를 사용하여 객체의 동일성을 확인할 수 있는 것은 JPA가 같은 트랜잭션 내에서 동일한 엔티티를 캐시를 통해 관리하기 때문입니다.
4. 요약
findMember == member가 true로 나오는 이유는 JPA의 1차 캐시로 인해 동일한 트랜잭션 내에서 동일한 엔티티가 동일한 인스턴스로 관리되기 때문입니다.
JPA는 EntityManager의 1차 캐시를 통해 동일한 트랜잭션 내에서 엔티티를 관리하고, 이로 인해 메모리에서 동일한 객체 참조를 유지하게 됩니다.
이런 동작 방식 덕분에 JPA를 사용할 때, 효율적으로 엔티티를 관리하고 성능을 높일 수 있습니다.


-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


엔티티 클래스 개발

- 실무에서는 가급적 Getter만 열어두고, Setter는 꼭 필요한 경우에만 사용하는 것을 추천.
    
이론적으로 Getter, Setter 모두 제공하지 않고, 꼭 필요한 별도의 메소드를 제공하는 것이 가장 이상적이다.
하지만 실무에서 Entity의 데이터는 조회할 일이 너무 많으므로, Getter의 경우 모두 열어두는 것이 편리하다.
Getter는 아무리 호출해도 호출 하는 것 만으로는 어떤 일이 발생하지 않는다. 하지만 Setter는 호출하면
데이터가 변한다. Setter를 막 열어두면 가까운 미래에 Entity가 도대체 왜 변경되는지 추적하기 점점 힘들어 진다.
그래서 Entity를 변경할 때는 Setter 대신 변경 지점이 명확하도록 변경을 위한
비즈니스 메소드를 별도로 제공해야 한다.


- 값 타입은 변경 불가능하게 설계해야 한다.

JPA 스펙상 Entity나 임베디드(@Embeddable)은 자바 기본 생성자를 public 또는 protected로 설정해야 한다. 그 중 protected가 더 안전하다.


- 모든 연관관계는 지연로딩으로 설정한다.

    o 즉시로딩(EAGER)은 예측이 어렵고, 어떤 SQL이 실행될지 추적하기 어렵다. N+1 문제가 자주 발생한다.
    
    o 실무에서 모든 연관관계는 지연로딩(LAZY)로 설정해야 한다.

    o 연관된 Entity를 함께 DB에서 조회해야 하면, fetch join 혹은 엔티티 그래프 기능을 사용한다.

    o @XToOne(OneToOne, ManyToOne) 관계는 기본이 즉시로딩이므로 직접 지연로딩으로 설정해야 한다.



-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


회원기능 테스트

- 테스트 코드를 작성할 때에는, 운영 application.yml과 테스트 application.yml 따로 사용한다.

- @RequiredArgsConstructor 어노테이션 사용.
  
    o privat final 메소드에 적용됨.
  
    o @Autowired를 사용하지 않고, 코드를 간결하게 사용할 수 있다.
